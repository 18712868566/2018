函数表达式
=================

* 定义函数逇方式有两种
    * 一种是函数声明
    * 一种就是函数表达式

> 函数声明的语法

```
function functionName(arg0,arg1,arg2){
    // 函数体
}
```

> `function`是关键字，ff,safari,chrome,opear都给函数定义了一个非标准的`name`属性，通过这个属性可以访问到给函数指定的名字

```
console.log(functionName.name);     //"functionName"
```


> 关于函数声明，他的一个重要特征就是`函数声明提升`，意思是在执行代码之前会先读取函数声明。这就意味着可以吧函数声明放在调用它的语句后面

```
sayHi();

function sayHi(){
    alert('Hi!');
}

```

> 函数表达式的语法，有几种不同形式

> 这种情况下创建的函数叫做`匿名函数`，匿名函数的`name属性是空字符串 `
```
var functionName = function (arg0,arg1,arg2){
    //函数体
};

```

> 函数表达式和其他表达式一样，在使用前必须先赋值，不然会导致错误

```
sayName();  //错误，函数还不存在

var sayName = function (){
    console.log('lixuefeng');
}
```
> 思考下面的代码
```
if(condition){
    function sayHi(){
        console.log('Hi!');
    }
}else{
    function sayHi(){
        console.log('HeHe!');
    }
}

/* ---------------- */

var sayHi;

if(condition){
    var sayHi = function (){
        console.log('Hi!');
    }
}else{
    var sayHi = function (){
        consol.log('HeHe!');
    }
}

```

> 能够创建函数在赋值给变量，也就能够把`函数作为其他函数的值返回`

```
function createComparisonFunction(propertyName) {
    return function (obj1, obj2) {
        var v1 = obj1[propertyName];
        var v2 = obj2[propertyName];

        if (v1 < v2) {
            return -1;
        } else if (v1 > v2) {
            return 1;
        } else {
            return 0;
        }
    }
}

```

## 递归

> 递归函数时在一个函数通过名字调用自身的情况下构成的

```
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
}

var num = factorial(10);
console.log(num);      // 3628800


var num2 = factorial;
factorial = null;   
console.log(num2(4));   //出错

// 
//当调用num2()时，必须执行 factorial(), 而现在 factorial 已经不再是函数，所以就会导致错误。
```

> 解决方法 ， `arguments.callee` 是一个指向`正在执行的函数的指针`,因此可以使用它来实现对函数逇递归调用

```
'use strict'
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}

var num = factorial(5);

console.log(num);//120

// 在严格模式下 脚本不能访问 ， arguments.callee, 访问这个属性会导致错误

// 可以使用命名函数表达式来达成相同的效果
```

> 通过使用命名函数表达式来打成相同的结果，在严格和非严格模式下都有效
```
'use strict'
var factorial = (function f(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num - 1);
    }
})

var num = factorial(5);
console.log(num);
```

## 闭包

