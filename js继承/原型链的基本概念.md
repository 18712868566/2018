如果我们让原型对象等于另一个类型的实例

此时的原型对象将包含一个指向另一个原型的指针

相应的,另一个原型中也包含着一个指向另一个构造函数的指针

假如另一个原型又是另一个类型的实例

那么上述关系依然成立,如此层层递进,就构成了实例与原型的链条

这就是所谓原型链的基本概念



理解:

构造函数

构造函数的prototype属性

构造函数的原型对象

和实例之间的关系

每个函数都有一个 prototype 的属性 指向 -->  构造函数的原型对象 -->

构造函数的原型对象有一个 constructor属性,这个属性 包含一个指向 prototype属性所在函数的指针

当调用构造函数创建一个实例后,实例内部有一个 [[prototype]] (__proto__)指针,指向构造函数的原型对象


继承--> 声明两个类型, 让A类型的原型对象等于B类型的实例,这样就重写了原型对象,
现在,B类型中的所有属性和方法,也存在与 A.prototype 中了

我们没有使用A的默认原型,相当于给A换了一个新原型 --> 就是B的实例

于是新原型不仅具有作为一个拥有B的实例所拥有的全部属性和方法,而且内部还有一个指针[[prototype]] (__proto__),指向B的原型对象,
